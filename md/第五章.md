## 第五章 映射器

- 映射器是**MyBatis**中最复杂且最重要的组件。它有一个接口加上一个**XML**文件(或**注解**)组成。**在映射器中可以配置参数，各类的SQL语句，存储过程，缓存，级联等复杂的内容。**
- **MyBatis**的映射器也可以使用注解完成，但是它在企业应用中不多，原因主要有3个：
  1. **面对复杂性，SQL会显得无力，尤其是长SQL。**
  2. **注解的可读性较差。**
  3. **注解丢失了XML上下文相互引用的功能。**

### 概述

- 映射器的配置元素

| 元素名称         | 描述                                                         | 备注                                              |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| **select**       | 查询语句，最常用，最复杂的元素之一                           | 可以自定义参数，返回结果集等                      |
| **insert**       | 插入语句                                                     | 执行后返回一个整数，代表插入的条数                |
| **update**       | 更新语句                                                     | 执行后返回一个整数，代表更新的条数                |
| **delete**       | 删除语句                                                     | 执行后返回一个整数，代表删除的条数                |
| ~~parameterMap~~ | 定义参数映射关系                                             | 即将被删除的元素，不建议使用                      |
| **sql**          | 允许定义一部分SQL，然后在各个地方引用它                      | 如，一张表列名，一次定义，可以在多个SQL语句中使用 |
| **resultMap**    | 用来描述从数据库结果集中来加载对象，它是最复杂，最强大的元素 | 它将提供映射规则                                  |
| **cache**        | 给定命名空间的缓存配置                                       | ——                                                |
| **cache-ref**    | 其他命名空间缓存配置的引用                                   |                                                   |

### select元素-查询语句

- select元素的配置

| 元素          | 说明                                                         | 备注                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| id            | 它和Mapper的命名空间组合起来是唯一的，供MyBatis使用          | 如果命名空间和id结合起来不唯一，MyBatis将抛出异常            |
| parameterType | 可以给出类的全类名，也可以给出别名，但是别名必须是MyBatis内部定义或自定义的 | 可以选择Java Bean，Map等简单的参数类型传递给SQL              |
| parameterMap  | 即将废弃的元素                                               |                                                              |
| resultType    | 定义类的全路径，在允许自动匹配的情况下，结果集将通过Java Bean的规范映射；或定义为int,double,float,map等参数；也可以使用别名，但是要符合别名规范，且不能和resultMap同时使用 | 常用的参数之一，比如统计总条数时可以把它的值设置为int        |
| resultMap     | 它是映射集的引用，将执行强大的映射功能。我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会 | MyBatis最复杂的元素，可以配置映射规则，级联，typeHandler等。 |
| flushCache    | 它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存 | 取值为布尔值，默认为false                                    |
| useCache      | 启动二级缓存的开关，是否要求MyBatis将此次结果缓存            | 取值为布尔型，默认false                                      |
| timeout       | 设置超时参数，超时时将抛出异常，以秒为单位                   | 默认值是数据库厂商提供的JDBC驱动所设置的秒数                 |
| fetchSize     | 获取记录的总条数设定                                         | 默认值是数据库厂商提供的JDBC驱动所设置的条数                 |
| resultSetType | 这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY(游标允许向前访问),SCROLL_SENSITIVE(双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不在resultSet中反应出来),SCROLL_INSENSITIVE(双向滚动，并及时跟踪数据库的更新，以便更改resultSET中的数据) | 默认值是数据库厂商提供的JDBC驱动所设置的                     |
| statementType | 告诉MyBatis使用哪个JDBC的Statement工作，取值为STATEMENT(Statement),PREPARED(PreparedStatement),CALLABLE(CallableStatement) | 默认值为PREPARED                                             |
| databaseId    | 前面第四章介绍过                                             | 提供多种数据库支持                                           |
| resultOrdered | 这个设置仅适用于嵌套结果select语句。如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行时，就不能引用前面的结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用 | 取值为布尔型，默认值为false                                  |
| resultSets    | 适合于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 | 较少使用                                                     |



#### 自动映射和驼峰映射

- **MyBatis**提供了自动映射功能，在**默认的情况下自动映射功能是开启**的，使用它的好处在于能有效**较少大量的映射配置**，从而减少工作量。

- 在**settings**元素中有两个可以配置的选项**autoMappingBehavior**和**mapUnderscoreToCamelCase**，它们是控制**自动映射**和**驼峰映射**的开关。一般而言，自动映射会使用的多一些。

- 配置自动映射的**autoMappingBehavior**选项的取值范围是：

  - **NONE**，不进行自动映射。
  - **PARTIAL**，默认值，只对没有进行嵌套结果集进行自动映射。
  - **FULL**，对所有的结果集进行自动映射，包括嵌套结果集。

- 第一步定义POJO

  - ```java
    public class Role {
        private Long id;
        private String roleName;
        private String note;
        //setting&getting
    }
    ```

- 第二步定义映射配置文件

  - ```xml
    <select id="getRole" parameterType="long" resultType="com.ssm.chapter5.pojo.Role">
    		select id,
    		role_name as roleName, note from t_role where id = #{id}
    	</select>
    ```

- 原来的列名**role_name**被**roleName**代替，这样就和**POJO**上的属性名保持一致。此时**MyBatis**就会将这个结果映射到**POJO**的属性**roleName**上，自动完成映射，而无须再进行任何配置。

- 如果系统严格按照驼峰命名法(如：数据库字段为**role_name**,则**POJO**属性名为**roleName**,数据库字段名为**user_name**，则**POJO**属性名为**userName**)，那么只要在配置项把**mapUnderscoreToCamelCase**设置为**true**即可。那么**SQL**可以改写为：

  - ```sql
    select id, role_name, note from t_role where id = #{id}
    ```

- **MyBatis**会**严格按照驼峰命名的方式做自动映射**，只是这样会要求数据库字段和**POJO**的属性名严格对应，**降低了灵活性**。

#### 传递多个参数

- 在现实中的需求中可能有多个参数，比如：订单可以通过订单编号查询，也可以根据订单名称，日期或者价格等参数进行查询，为此要传递多个参数，假设要通过角色名称(**role_name**)和备注(**note**)对角色进行模糊查询，这样就有了两个参数。

##### 使用map接口传递参数

- 在**MyBatis**中允许使用**map**接口通过键值对传递多个参数，定义接口方法。

  - ```java
    public List<Role> findRolesByMap(Map<String,Object> parameterMap);
    ```

- 配置**XML**文件

  - ```xml
    <select id="findRolesByMap" parameterType="map" resultType="role">
    		select id, role_name as roleName, note from t_role
    		where role_name like
    		concat('%', #{roleName}, '%')
    		and note like concat('%', #{note}, '%')
    	</select>
    ```

- 注意：参数**roleName**和**note**，要求的是**map**的键。

- 添加测试类

  - ```java
    @Test
    	public void testFindRolesByMap() {
    		SqlSession sqlSession = null;
    		try {
    			sqlSession = SqlSessionFactoryUtils.openSqlSession();
    			RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);
    			Map<String, Object> parameterMap = new HashMap<String, Object>();
    			parameterMap.put("roleName", "1");
    			parameterMap.put("note", "1");
    			List<Role> roles = roleMapper.findRolesByMap(parameterMap);
    			System.out.println(roles.size());
    		} catch(Exception ex) {
    			ex.printStackTrace();
    		} finally {
    			if (sqlSession != null) {
    				sqlSession.close();
    			}
    		}
    	}
    ```

- 在**SQL**中的参数标识将会被这里设置的参数所取代，这样就能够运行了。但是**map**适用的场景不多，原因如下：

  - **map**是一个键值对应的集合，使用者要通过阅读它的键，才能明白其作用。
  - 使用**map**不能限定其传递的数据类型，因此业务性质不强，可读性差。

#### 使用注解传递多个参数

- **MyBatis**为开发者提供了一个注解**@Param**(org.apache.ibatis.annotations.Param)，通过它去定义映射器的参数名称，使用它可以得到更好的可读性。

- 定义接口

  - ```java
    public List<Role> findRoleByAnnotation(@Param("roleName") String rolename,@Param("note") String note);
    ```

- 配置XML文件

  - ```xml
    <select id="findRoleByAnnotation" resultType="role">
    	select id, role_name as roleName, note from t_role where role_name like concat('%', #{roleName}, '%') and note like concat('%', #{note}, '%')
    </select>
    ```

  - 

