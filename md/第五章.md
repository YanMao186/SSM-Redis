## 第五章 映射器

- 映射器是**MyBatis**中最复杂且最重要的组件。它有一个接口加上一个**XML**文件(或**注解**)组成。**在映射器中可以配置参数，各类的SQL语句，存储过程，缓存，级联等复杂的内容。**
- **MyBatis**的映射器也可以使用注解完成，但是它在企业应用中不多，原因主要有3个：
  1. **面对复杂性，SQL会显得无力，尤其是长SQL。**
  2. **注解的可读性较差。**
  3. **注解丢失了XML上下文相互引用的功能。**

### 概述

- 映射器的配置元素

| 元素名称         | 描述                                                         | 备注                                              |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| **select**       | 查询语句，最常用，最复杂的元素之一                           | 可以自定义参数，返回结果集等                      |
| **insert**       | 插入语句                                                     | 执行后返回一个整数，代表插入的条数                |
| **update**       | 更新语句                                                     | 执行后返回一个整数，代表更新的条数                |
| **delete**       | 删除语句                                                     | 执行后返回一个整数，代表删除的条数                |
| ~~parameterMap~~ | 定义参数映射关系                                             | 即将被删除的元素，不建议使用                      |
| **sql**          | 允许定义一部分SQL，然后在各个地方引用它                      | 如，一张表列名，一次定义，可以在多个SQL语句中使用 |
| **resultMap**    | 用来描述从数据库结果集中来加载对象，它是最复杂，最强大的元素 | 它将提供映射规则                                  |
| **cache**        | 给定命名空间的缓存配置                                       | ——                                                |
| **cache-ref**    | 其他命名空间缓存配置的引用                                   |                                                   |

### select元素-查询语句

- select元素的配置

| 元素          | 说明                                                         | 备注                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| id            | 它和Mapper的命名空间组合起来是唯一的，供MyBatis使用          | 如果命名空间和id结合起来不唯一，MyBatis将抛出异常            |
| parameterType | 可以给出类的全类名，也可以给出别名，但是别名必须是MyBatis内部定义或自定义的 | 可以选择Java Bean，Map等简单的参数类型传递给SQL              |
| parameterMap  | 即将废弃的元素                                               |                                                              |
| resultType    | 定义类的全路径，在允许自动匹配的情况下，结果集将通过Java Bean的规范映射；或定义为int,double,float,map等参数；也可以使用别名，但是要符合别名规范，且不能和resultMap同时使用 | 常用的参数之一，比如统计总条数时可以把它的值设置为int        |
| resultMap     | 它是映射集的引用，将执行强大的映射功能。我们可以使用resultType和resultMap其中的一个，resultMap能提供自定义映射规则的机会 | MyBatis最复杂的元素，可以配置映射规则，级联，typeHandler等。 |
| flushCache    | 它的作用是在调用SQL后，是否要求MyBatis清空之前查询本地缓存和二级缓存 | 取值为布尔值，默认为false                                    |
| useCache      | 启动二级缓存的开关，是否要求MyBatis将此次结果缓存            | 取值为布尔型，默认false                                      |
| timeout       | 设置超时参数，超时时将抛出异常，以秒为单位                   | 默认值是数据库厂商提供的JDBC驱动所设置的秒数                 |
| fetchSize     | 获取记录的总条数设定                                         | 默认值是数据库厂商提供的JDBC驱动所设置的条数                 |
| resultSetType | 这是对JDBC的resultSet接口而言，它的值包括FORWARD_ONLY(游标允许向前访问),SCROLL_SENSITIVE(双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不在resultSet中反应出来),SCROLL_INSENSITIVE(双向滚动，并及时跟踪数据库的更新，以便更改resultSET中的数据) | 默认值是数据库厂商提供的JDBC驱动所设置的                     |
| statementType | 告诉MyBatis使用哪个JDBC的Statement工作，取值为STATEMENT(Statement),PREPARED(PreparedStatement),CALLABLE(CallableStatement) | 默认值为PREPARED                                             |
| databaseId    | 前面第四章介绍过                                             | 提供多种数据库支持                                           |
| resultOrdered | 这个设置仅适用于嵌套结果select语句。如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行时，就不能引用前面的结果集了。这就确保了在获取嵌套的结果集时不至于导致内存不够用 | 取值为布尔型，默认值为false                                  |
| resultSets    | 适合于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 | 较少使用                                                     |



#### 自动映射和驼峰映射

- **MyBatis**提供了自动映射功能，在**默认的情况下自动映射功能是开启**的，使用它的好处在于能有效**较少大量的映射配置**，从而减少工作量。

- 在**settings**元素中有两个可以配置的选项**autoMappingBehavior**和**mapUnderscoreToCamelCase**，它们是控制**自动映射**和**驼峰映射**的开关。一般而言，自动映射会使用的多一些。

- 配置自动映射的**autoMappingBehavior**选项的取值范围是：

  - **NONE**，不进行自动映射。
  - **PARTIAL**，默认值，只对没有进行嵌套结果集进行自动映射。
  - **FULL**，对所有的结果集进行自动映射，包括嵌套结果集。

- 第一步定义POJO

  - ```java
    public class Role {
        private Long id;
        private String roleName;
        private String note;
        //setting&getting
    }
    ```

- 第二步定义映射配置文件

  - ```xml
    <select id="getRole" parameterType="long" resultType="com.ssm.chapter5.pojo.Role">
    		select id,
    		role_name as roleName, note from t_role where id = #{id}
    	</select>
    ```

- 原来的列名**role_name**被**roleName**代替，这样就和**POJO**上的属性名保持一致。此时**MyBatis**就会将这个结果映射到**POJO**的属性**roleName**上，自动完成映射，而无须再进行任何配置。

- 如果系统严格按照驼峰命名法(如：数据库字段为**role_name**,则**POJO**属性名为**roleName**,数据库字段名为**user_name**，则**POJO**属性名为**userName**)，那么只要在配置项把**mapUnderscoreToCamelCase**设置为**true**即可。那么**SQL**可以改写为：

  - ```sql
    select id, role_name, note from t_role where id = #{id}
    ```

- **MyBatis**会**严格按照驼峰命名的方式做自动映射**，只是这样会要求数据库字段和**POJO**的属性名严格对应，**降低了灵活性**。

#### 传递多个参数

- 在现实中的需求中可能有多个参数，比如：订单可以通过订单编号查询，也可以根据订单名称，日期或者价格等参数进行查询，为此要传递多个参数，假设要通过角色名称(**role_name**)和备注(**note**)对角色进行模糊查询，这样就有了两个参数。

##### 使用map接口传递参数

- 在**MyBatis**中允许使用**map**接口通过键值对传递多个参数，定义接口方法。

  - ```java
    public List<Role> findRolesByMap(Map<String,Object> parameterMap);
    ```

- 配置**XML**文件

  - ```xml
    <select id="findRolesByMap" parameterType="map" resultType="role">
    		select id, role_name as roleName, note from t_role
    		where role_name like
    		concat('%', #{roleName}, '%')
    		and note like concat('%', #{note}, '%')
    	</select>
    ```

- 注意：参数**roleName**和**note**，要求的是**map**的键。

- 添加测试类

  - ```java
    @Test
    	public void testFindRolesByMap() {
    		SqlSession sqlSession = null;
    		try {
    			sqlSession = SqlSessionFactoryUtils.openSqlSession();
    			RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);
    			Map<String, Object> parameterMap = new HashMap<String, Object>();
    			parameterMap.put("roleName", "1");
    			parameterMap.put("note", "1");
    			List<Role> roles = roleMapper.findRolesByMap(parameterMap);
    			System.out.println(roles.size());
    		} catch(Exception ex) {
    			ex.printStackTrace();
    		} finally {
    			if (sqlSession != null) {
    				sqlSession.close();
    			}
    		}
    	}
    ```

- 在**SQL**中的参数标识将会被这里设置的参数所取代，这样就能够运行了。但是**map**适用的场景不多，原因如下：

  - **map**是一个键值对应的集合，使用者要通过阅读它的键，才能明白其作用。
  - 使用**map**不能限定其传递的数据类型，因此业务性质不强，可读性差。

##### 使用注解传递多个参数

- **MyBatis**为开发者提供了一个注解**@Param**(org.apache.ibatis.annotations.Param)，通过它去定义映射器的参数名称，使用它可以得到更好的可读性。

- 定义接口

  - ```java
    public List<Role> findRoleByAnnotation(@Param("roleName") String rolename,@Param("note") String note);
    ```

- 配置XML文件

  - ```xml
    <select id="findRoleByAnnotation" resultType="role">
    	select id, role_name as roleName, note from t_role where role_name like concat('%', #{roleName}, '%') and note like concat('%', #{note}, '%')
    </select>
    ```

- 添加测试

  - ```java
    @Test
    	public void testFindRolesByAnnotation() {
    		SqlSession sqlSession = null;
    		try {
    			sqlSession = SqlSessionFactoryUtils.openSqlSession();
    			RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);
    			List<Role> roles = roleMapper.findRolesByAnnotation("1", "1");
    			System.out.println(roles.size());
    		} catch(Exception ex) {
    			ex.printStackTrace();
    		} finally {
    			if (sqlSession != null) {
    				sqlSession.close();
    			}
    		}
    	}
    ```

- 注意：此时并不需要给出**parameterType**属性，让**MyBatis**自动探索就可以了。

- 但是如果**SQL**很复杂，用于大于**10**个参数，那么接口方法的参数个数就多了，使用起来就很不容易了。不过**MyBatis**还提供了传递**Java Bean**的形式。

##### 通过Java Bean传递多个参数

- 定义实体类

  - ```java
    public class RoleParams {
        public String roleName;
       	public String note;
       	//setting && getting
    }
    ```

- 定义接口

  - ```java
    public List<Role> findRolesByBean(RoleParams roleParam);
    ```

- 配置XML文件

  - ```xml
    <select id="findRolesByBean" parameterType="xxx.xxx.xxx.RoleParams" resultType="role">
    	select id role_name as roleName, note from t_role where role_name like concat('%', #{roleName}, '%') and note like concat('%', #{note}, '%')
    </select>
    ```

- 添加测试

  - ```java
    @Test
    	public void testFindRolesByBean() {
    		SqlSession sqlSession = null;
    		try {
    			sqlSession = SqlSessionFactoryUtils.openSqlSession();
    			RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);
    			RoleParams roleParam = new RoleParams();
    			roleParam.setNote("1");
    			roleParam.setRoleName("1");
    			List<Role> roles = roleMapper.findRolesByBean(roleParam);
    			System.out.println(roles.size());
    		} catch(Exception ex) {
    			ex.printStackTrace();
    		} finally {
    			if (sqlSession != null) {
    				sqlSession.close();
    			}
    		}
    	}
    ```

##### 混合配置

- 在某些情况下可能需要使用几种方式来传递参数，如查询一个角色，可以通过角色名称和备注进行查询，与此同时还需要支持分页。

- 定义分页实体类

  - ```java
    public class PageParams {
        private int start;
        private int limit;
        //setting && getting
    }
    ```

- 定义接口

  - ```java
    public List<Role> findByMix(@Param("Params") RoleParams roleParams,@Params("page") PageParams pageparam)
    ```

- 配置XML映射文件

  - ```xml
    <select id="findByMix" resultType="role">
    		select id, role_name as
    		roleName, note from t_role
    		where role_name like
    		concat('%',
    		#{params.roleName}, '%')
    		and note like concat('%', #{params.note}, '%')
    		limit #{page.start}, #{page.limit}
    	</select>
    ```

- 添加测试

  - ```java
    @Test
    	public void testFindByMix() {
    		SqlSession sqlSession = null;
    		try {
    			sqlSession = SqlSessionFactoryUtils.openSqlSession();
    			RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);
    			RoleParams roleParam = new RoleParams();
    			roleParam.setNote("n");
    			roleParam.setRoleName("r");
    			PageParams pageParams = new PageParams();
    			pageParams.setStart(0);
    			pageParams.setLimit(100);
    			List<Role> roles = roleMapper.findByMix(roleParam, pageParams);
    			System.out.println(roles.size());
    			for (Role role : roles) {
    				System.out.println(role);
    			}
    		} catch(Exception ex) {
    			ex.printStackTrace();
    		} finally {
    			if (sqlSession != null) {
    				sqlSession.close();
    			}
    		}
    	}
    ```

##### 总结

1. 使用**map**传递参数导致了业务可读性的丧失，导致后续扩展性和维护性的困难，在实际的应用中要果断废弃这种方式。
2. 使用**@Param**注解传递多个参数，受到参数个数(n)的影响。当**n<=5**时，这是最佳的传参方式，当**n>=5**时，多个参数将给调用带来困难，此时不推荐使用它。
3. 当参数个数多于**5**个时，建议使用**Java Bean**方式。
4. 当使用混合参数的，要明确参数的合理性。

#### 使用resultMap映射结果集

- 之前介绍的自动映射和驼峰映射比较简单，无法定义太多的属性，比如：**typeHandler**，**级联**等。为了支持复杂的映射，**select**提供了**resultMap**属性。

  - ```xml
    <mapper namespace="com.ssm.chapter5.mapper.RoleMapper">
        <resultMap id="roleMap" type="role">
                <id property="id" column="id" />
                <result property="roleName" column="role_name" />
                <result property="note" column="note" />
            </resultMap>
    
            <select id="getRoleUseResultMap" parameterType="long" resultMap="roleMap">
                select id, role_name, note from t_role where id = #{id}
            </select>
    </mapper>
    ```

- **resultMap**元素定义了一个**roleMap**，它的属性**id**表示代表它的**标识**，**type**表示使用的是哪个类作为其映射的类，可以是**全限定名**或**别名**。

- 它的子元素**id**代表**resultMap**的主键，而**result**代表其属性，**id**和**result**元素的属性**property**代表**POJO**的属性名称，而**column**代表**SQL**的列名，从而建立**POJO**与**SQL**的映射。

- 在**select**元素中的属性**resultMap**制定了采用哪个**resultMap**作为其映射规则。

#### 分页参数RowBounds

- **MyBatis**中内置了一个专门处理分页的类**RowBounds**。

  - ```java
    package org.apache.ibatis.session;
    
    public class RowBounds {
        public static final int NO_ROW_OFFSET = 0;
        public static final int NO_ROW_LIMIT = 2147483647;
        public static final RowBounds DEFAULT = new RowBounds();
        private int offset;
        private int limit;
    
        public RowBounds() {
            this.offset = 0;
            this.limit = 2147483647;
        }
    
        public RowBounds(int offset, int limit) {
            this.offset = offset;
            this.limit = limit;
        }
    
        public int getOffset() {
            return this.offset;
        }
    
        public int getLimit() {
            return this.limit;
        }
    }
    ```

- **offset**属性是**偏移量**，即从第几行开始读取记录，**limit**是限制条数，默认值为**0~2147483647**，使用十分简单，只要给接口增加一个**RowBounds**参数即可。

  - ```java
    public List<Role> findByRowBounds(@Param("roleName") String rolename,@Param("note") String note,RowBounds rowBounds);
    ```

- 编写**XML**映射文件，不需要**RowBounds**

  - ```xml
    <select id="findByRowBounds" resultType="role">
    	select id, role_name as roleName, note from t_role where role_name like concat('%', #{roleName}, '%') and note like concat('%', #{note}, '%')
    </select>
    ```

- 添加测试

  - ```java
    @Test
    	public void testFindByRowBounds() {
    		SqlSession sqlSession = null;
    		try { sqlSession = SqlSessionFactoryUtils.openSqlSession();
    		RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);
    		RowBounds rowBounds = new RowBounds(0,20);
    		List<Role> roleList = roleMapper.findByRowBounds("role_name", "note", rowBounds);
    		System.err.println(roleList.size());
    			System.err.println(roleList);
    		}catch (Exception e) {
    			e.printStackTrace();
    		}finally {
    			if (sqlSession != null) {
    				sqlSession.close();
    			}
    		}
    	}
    ```

- **RowBounds**分页运用的场景，它只能运用于一些小数据量的查询。**RowBounds**分页的原理是执行**SQL**的查询后，按照偏移量和限制条数返回查询结果，所以对于大量的数据查询，它的性能并不佳。

### insert元素-插入语句

- insert元素的配置

| 属性                 | 描述                                                         | 备注                                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **id**               | **SQL**编号，用于标识这条**SQL**                             | 命名空间+**id**+**databaseId**唯一，否则**MyBatis**会抛出异常 |
| **parameterType**    | 参数类型                                                     | 和**select**一样，可以是单个参数或者多个参数                 |
| ~~**parameterMap**~~ | 参数的**map**，即将废弃                                      |                                                              |
| **flushCache**       | 是否刷新缓存，可以配置**true/false**，为**true**时，插入时会刷新一级和二级缓存，否则不刷新 | 默认值为**true**                                             |
| **timeout**          | 超时时间，单位为秒                                           |                                                              |
| **statementType**    | **STATEMENT**,**PREPARED**或**CALLABLE**中的一个。这会让**MyBatis**分别使用**Statement**，**PreparedStatement**(预编译)或**CallableStatement**(存储过程) | 默认值为**PREPARED**                                         |
| **useGeneratedKeys** | 是否开启**JDBC**的**getGeneratedKeys**方法来取出由数据库内部生成的主键(比如**MySQL**和**SQL Server**这样的数据库表的自增主键) | 默认值为**false**                                            |
| **keyProperty**      | (仅对**insert**和**update**有用)唯一标识一个属性，**MyBatis**会通过**getGeneratedKeys**的返回值，或者通过**insert**语句的**selectKey**子元素设置它的键值。如果是符合主键，要把每一个名称用逗号(，)隔开 | 默认值为**unset**。不能和**keyColumn**连用                   |
| **keyColumn**        | (仅对**insert**和**update**有用)唯一标识一个属性，**MyBatis**会通过**getGeneratedKeys**的返回值，或者通过**insert**语句的**selectKey**子元素设置它的键值，如果是复合主键，要把每一个名称用逗号(,)隔开 | 不能和**keyProperty**连用                                    |
| **databaseId**       | 上一章介绍过                                                 |                                                              |

- **MyBatis**在执行完一条**insert**语句后，会返回一个整数表示其影响的记录数。

#### 简单的insert语句的应用

- ```xml
  <insert id="insertRole" parameterType="role">
  		insert into t_role(role_name, note) values(#{roleName},
  		#{note})
  	</insert>
  ```

#### 主键回填

- 上面的代码它并没有插入**id**列，因为**MySQL**中的表格采用了**自增主键**。

- **JDBC**中的**Statement**对象在执行插入的**SQL**后，可以通过**getGeneratedKeys**方法获得数据库生成的主键(需要数据库驱动的支持)，这样便能达到主键的功能。在**insert**语句中有一个开关属性**useGeneratedKeys**，用来控制是否打开这个功能，它的默认值是**false**。当打开了这个开关，还要配置其属性**keyProperty**或**keyColumn**，告诉系统把生成的主键放在哪个属性中，如果存在多个主键，就要用逗号(,)将它们隔开。

- 编写接口

  - ```java
    public int insertRole(Role role);
    ```

- 配置**xml**映射文件

  - ```xml
    <insert id="insertRole" parameterType="role" useGeneratedKeys="true"
    		keyProperty="id">
    		insert into t_role(role_name, note) values(#{roleName},
    		#{note})
    	</insert>
    ```

- **useGeneratedKeys**代表采用**JDBC**的**Statement**对象的**getGeneratedKeys**方法返回主键，而**keyProperty**则代表将用哪个**POJO**的属性去匹配这个主键。此处是id。

- 添加测试

  - ```java
    @Test
    	public void testInsertRole() {
    		SqlSession sqlSession = null;
    		try {
    			sqlSession = SqlSessionFactoryUtils.openSqlSession();
    			RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);
    			Role role = new Role();
    			role.setRoleName("role_name_5");
    			role.setNote("note_5");
    			roleMapper.insertRole(role);
    			//����
    			System.out.println(role.getId());
    			sqlSession.commit();
    		} catch(Exception ex) {
    			sqlSession.rollback();
    			ex.printStackTrace();
    		} finally {
    			if (sqlSession != null) {
    				sqlSession.close();
    			}
    		}
    	}
    ```

#### 自定义主键

- 有时候主键可能依赖于某些规则，比如取消角色表(**r_role**)的**id**递增规则，而将其规则修改为：
  - 当角色表记录为空时，**id**设置为**1**。
  - 当角色表记录不为空时，**id**设置为当前**id**加3

- **MyBatis**对这样的场景也提供了支持，它主要依赖于**selectKey**元素进行支持，它允许自定义键值的生成规则。

  - ```xml
    <insert id="insertRole" parameterType="role">
    	<selectKey keyProperty="id" resultType="long" order="BEFORE">
        	select if (max(id) = null, 1, max(id) + 3) from t_role
        </selectKey>
        insert into t_role(id, role_name, note) values(#{id}, #{roleName}, #{note})
    </insert>
    ```

- **selectKey**元素，它的**keyProperty**指定了采用哪个属性作为**POJO**的主键，**resultType**告诉**MyBatis**将返回一个**long**型的结果集，而**order**设置为**BEFORE**，说明它将于当前定义的**SQL**前执行。

### update和delete元素

- 它们和**insert**的属性差不多，执行完也会返回一个整数，用于标识该**SQL**语句影响了数据库的记录行数。

  - ```xml
    <update id="updateRole" parameterType="role">
    		update t_role set role_name = #{roleName}, note = #{note}
    		where id = #{id}
    	</update>
    	
    	<delete id="deleteRole" parameterType="long">
    		delete from t_role where id = #{id}
    	</delete>
    ```

### sql元素

- **sql**元素的作用在于可以定义一条**SQL**的一部分，方便后面的**SQL**引用它，比如最典型的列名，而在**MyBatis**中只需要使用**sql**元素编写一次便能在其他元素中引用它。

  - ```xml
    <sql id="roleCols">
    	id, role_name, note
    </sql>
    <select id="getRole" parameterType="long" resultMap="roleMap">
    	select <include refid="roleCols"/> from t_role where id = #{id}
    </select>
    ```

- 通过**sql**元素进行了定义，就可以通过**include**元素引入到各条**SQL**中了。这样的代码，在字段多的数据库表中可以重复使用。

- **sql**元素还支持变量传递

  - ```xml
    <sql id="roleCols">
    	${alias}.id, ${alias}.role_name, ${alias}.note
    </sql>
    <select id="getRole" parameterType="long" resultMap="roleMap">
    	select
    <include refid="roleCols">
        		<property name="alias" value="r"/>
    </include>
        from t_role r where id = #{id}
    </select>
    ```

- 在**include**元素中定义了一个命名为**alias**的变量，其值是**SQL**表中**t_role**的别名**r**，然后**sql**元素就能够使用这个变量名了。

### 参数

- 一些数据库字段返回为null，而MyBatis系统又检测不到使用了何种jdbcType进行处理时，会发生异常的情况这个时候执行对应的typeHandler进行处理，MyBatis就知道采取哪个typeHandler进行处理了，如：

  - ```
    
    ```

  - 




