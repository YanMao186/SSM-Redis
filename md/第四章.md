## 第四章 MyBatis配置

### 概述

- **MyBatis**配置文件中所有出现的标签。

- ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <configuration>							        <!-- 配置 -->
      <properties/>							    <!-- 属性 -->
      <settings/>									<!-- 设置 -->
      <typeAliases/>							    <!-- 类型命名 -->
      <typeHandlers/>								<!-- 类型处理器 -->
      <objectFactory/>							<!-- 对象工厂 -->
      <plugins/>									<!-- 插件 -->
      <environments/>							    <!-- 配置环境 -->
          <environment>						    <!-- 环境变量 -->
              <transactionManager/>			    <!-- 事务管理器 -->
              <dataSource/>						<!-- 数据源 -->
          </environments>
      </environments>    
  	<databaseIdProvider/>						<!-- 数据库厂商标识 -->
  	<mappers/>									<!-- 映射器 -->
  </configuration>
  ```

- **MyBatis**配置项的**顺序不能颠倒**。如果颠倒了它们的顺序，那么在**MyBatis**启动阶段就会**发生异常**，导致程序**无法运行**。

### Properties属性

- **properties**属性可以给系统配置一些运行参数，可以放在**XML**文件或者**properties**文件中，而不是放在**Java**编码中，**MyBatis**提供了**3种方式**让我们使用**properties**。分别是：
  1. **property子元素**
  2. **properties文件**
  3. **程序代码传递**

#### property子元素

- ```xml
  ?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <configuration>
      <properties>
  		<property name="database.driver" value="com.mysql.jdbc.Driver"/> 
      	<property name="database.url" value="jdbc:mysql://localhost:3306/chapter4"/> 
          <property name="database.username" value="root"/> 
          <property name="database.password" value="123456"/>
  	</properties>
  	<typeAliases><!-- 别名 -->
  		<typeAlias alias="role" type="com.learn.ssm.chapter4.pojo.Role"/>
  		<package name="com.learn.ssm.chapter4.pojo" />
  	</typeAliases>
  	<!-- 数据库环境 -->
  	<environments default="development">
  		<environment id="development">
  			<transactionManager type="JDBC" />
  			<dataSource type="com.learn.ssm.chapter4.datasource.DbcpDataSourceFactory">
  				<property name="driver" value="${database.driver}" />
  				<property name="url" value="${database.url}" />
  				<property name="username" value="${database.username}" />
  				<property name="password" value="${database.password}" />
  			</dataSource>
  		</environment>
  	</environments>
  	<mappers>
  		<mapper resource="com/learn/ssm/chapter3/mapper/RoleMapper.xml" />
  	</mappers>
  </configuration>
  ```

- 这里使用了元素<properties>下的子元素<property>定义，用字符串**database.username**定义数据库用户名，然后就可以在数据库中引入这个定义好的属性参数，如**${database.username}**，这样定义一次就可以到处引用了。

#### 使用properties文件

- 使用**properties**文件是比较普遍的方法，一方面这个文件十分简单，其逻辑就是键值对应，我们可以配置多个键值放在一个**properties**文件中，也可以把多个键值放到多个**properties**文件中，这些都是允许的。

- ```properties
  database.driver=com.mysql.jdbc.Driver
  database.url=jdbc:mysql://localhost:3306/ssm-redis
  database.username=root
  database.password=root
  ```

- 在**MyBatis**中通过<properties>的属性**resource**来引入**properties**文件

- ````xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <configuration>
  	<properties resource="jdbc.properties">
  	</properties>
  	<typeAliases><!-- 别名 -->
  	<typeAlias alias="role" type="com.learn.ssm.chapter4.pojo.Role"/>
  		<package name="com.learn.ssm.chapter4.pojo" />
  	</typeAliases>
  	<!-- 数据库环境 -->
  	<environments default="development">
  		<environment id="development">
  			<transactionManager type="JDBC" />
  			<dataSource type="com.learn.ssm.chapter4.datasource.DbcpDataSourceFactory">
  				<property name="driver" value="${database.driver}" />
  				<property name="url" value="${database.url}" />
  				<property name="username" value="${database.username}" />
  				<property name="password" value="${database.password}" />
  			</dataSource>
  		</environment>
  	</environments>
  	<mappers>
  		<mapper resource="com/learn/ssm/chapter3/mapper/RoleMapper.xml" />
  	</mappers>
  </configuration>
  ````

#### 使用程序传递方式传递参数

<<<<<<< HEAD
- 在真实环境中，数据库的用户名是对开发人员和其他人员保密的，运维人员为了保密，一般需要把用户和密码经过加密成密文后，配置到properties文件中，先假设系统已经为提供了这样一个CodeUtils.decode(str)进行解密，那么我们在创建SqlSessionFactory前，就需要把用户名和密码进行解密，然后把解密后的字符串重置到properties属性中。

- ```java
  public class SqlSessionFactoryUtils {
      private final static Class<SqlSessionFactoryUtils> LOCK = SqlSessionFactoryUtils.class;
  
      private static SqlSessionFactory sqlSessionFactory = null;
  
      private  SqlSessionFactoryUtils() {
      }
  
      public static SqlSessionFactory getSqlSessionFactory() throws IOException {
          synchronized (LOCK) {
              if (sqlSessionFactory != null) {
                  return sqlSessionFactory;
              }
              String resource = "mybatis-config.xml";
              InputStream inputStream;
                  //采用程序传递加密参数,启用它之前，修改用户密码为密文，可参考main方法......
  				InputStream in = Resources.getResourceAsStream("jdbc.properties");
  				Properties props = new Properties();
  				props.load(in);
  				String username = props.getProperty("database.username");
  				String password = props.getProperty("database.password");
  				// 解密用户和密码，并在属性中重置
  				props.put("database.username", CodeUtils.decode(username));
  				props.put("database.password", CodeUtils.decode(password));
  				inputStream = Resources.getResourceAsStream(resource);
  				// 使用程序传递的方式覆盖原有的properties属性参数
  				sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, props);
              return sqlSessionFactory;
          }
      }
      public static SqlSession openSqlSession() throws IOException {
          if (sqlSessionFactory == null) {
              getSqlSessionFactory();
          }
          return sqlSessionFactory.openSession();
      }
  
      public static void main(String[] args) {
          System.out.println(CodeUtils.encode("root"));
          System.out.println(CodeUtils.encode("123456"));
      }
  
      static class CodeUtils {
          private static String encode(String src) {
              BASE64Encoder encoder = new BASE64Encoder();
              return encoder.encode(src.getBytes());
          }
  
          private static String decode(String des) {
              BASE64Decoder decoder = new BASE64Decoder();
              try {
                  return new String(decoder.decodeBuffer(des));
              } catch (IOException e) {
                  e.printStackTrace();
              }
              return null;
          }
      }
  }
  ```

- 
=======
- 

>>>>>>> origin/master
