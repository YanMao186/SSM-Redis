## 第四章 MyBatis配置

### 概述

- **MyBatis**配置文件中所有出现的标签。

- ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <configuration>							        <!-- 配置 -->
      <properties/>							    <!-- 属性 -->
      <settings/>									<!-- 设置 -->
      <typeAliases/>							    <!-- 类型命名 -->
      <typeHandlers/>								<!-- 类型处理器 -->
      <objectFactory/>							<!-- 对象工厂 -->
      <plugins/>									<!-- 插件 -->
      <environments/>							    <!-- 配置环境 -->
          <environment>						    <!-- 环境变量 -->
              <transactionManager/>			    <!-- 事务管理器 -->
              <dataSource/>						<!-- 数据源 -->
          </environments>
      </environments>    
  	<databaseIdProvider/>						<!-- 数据库厂商标识 -->
  	<mappers/>									<!-- 映射器 -->
  </configuration>
  ```

- **MyBatis**配置项的**顺序不能颠倒**。如果颠倒了它们的顺序，那么在**MyBatis**启动阶段就会**发生异常**，导致程序**无法运行**。

### Properties属性

- **properties**属性可以给系统配置一些运行参数，可以放在**XML**文件或者**properties**文件中，而不是放在**Java**编码中，**MyBatis**提供了**3种方式**让我们使用**properties**。分别是：
  1. **property子元素**
  2. **properties文件**
  3. **程序代码传递**

#### property子元素

- ```xml
  ?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <configuration>
      <properties>
  		<property name="database.driver" value="com.mysql.jdbc.Driver"/> 
      	<property name="database.url" value="jdbc:mysql://localhost:3306/chapter4"/> 
          <property name="database.username" value="root"/> 
          <property name="database.password" value="123456"/>
  	</properties>
  	<typeAliases><!-- 别名 -->
  		<typeAlias alias="role" type="com.learn.ssm.chapter4.pojo.Role"/>
  		<package name="com.learn.ssm.chapter4.pojo" />
  	</typeAliases>
  	<!-- 数据库环境 -->
  	<environments default="development">
  		<environment id="development">
  			<transactionManager type="JDBC" />
  			<dataSource type="com.learn.ssm.chapter4.datasource.DbcpDataSourceFactory">
  				<property name="driver" value="${database.driver}" />
  				<property name="url" value="${database.url}" />
  				<property name="username" value="${database.username}" />
  				<property name="password" value="${database.password}" />
  			</dataSource>
  		</environment>
  	</environments>
  	<mappers>
  		<mapper resource="com/learn/ssm/chapter3/mapper/RoleMapper.xml" />
  	</mappers>
  </configuration>
  ```

- 这里使用了元素<properties>下的子元素<property>定义，用字符串**database.username**定义数据库用户名，然后就可以在数据库中引入这个定义好的属性参数，如**${database.username}**，这样定义一次就可以到处引用了。

#### 使用properties文件

- 使用**properties**文件是比较普遍的方法，一方面这个文件十分简单，其逻辑就是键值对应，我们可以配置多个键值放在一个**properties**文件中，也可以把多个键值放到多个**properties**文件中，这些都是允许的。

- ```properties
  database.driver=com.mysql.jdbc.Driver
  database.url=jdbc:mysql://localhost:3306/ssm-redis
  database.username=root
  database.password=root
  ```

- 在**MyBatis**中通过<properties>的属性**resource**来引入**properties**文件

- ````xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <configuration>
  	<properties resource="jdbc.properties">
  	</properties>
  	<typeAliases><!-- 别名 -->
  	<typeAlias alias="role" type="com.learn.ssm.chapter4.pojo.Role"/>
  		<package name="com.learn.ssm.chapter4.pojo" />
  	</typeAliases>
  	<!-- 数据库环境 -->
  	<environments default="development">
  		<environment id="development">
  			<transactionManager type="JDBC" />
  			<dataSource type="com.learn.ssm.chapter4.datasource.DbcpDataSourceFactory">
  				<property name="driver" value="${database.driver}" />
  				<property name="url" value="${database.url}" />
  				<property name="username" value="${database.username}" />
  				<property name="password" value="${database.password}" />
  			</dataSource>
  		</environment>
  	</environments>
  	<mappers>
  		<mapper resource="com/learn/ssm/chapter3/mapper/RoleMapper.xml" />
  	</mappers>
  </configuration>
  ````

#### 使用程序传递方式传递参数

- 在真实环境中，数据库的用户名是对开发人员和其他人员保密的，运维人员为了保密，一般需要把用户和密码经过加密成密文后，配置到**properties**文件中，先假设系统已经为提供了这样一个**CodeUtils.decode(str)**进行解密，那么我们在创建**SqlSessionFactory**前，就需要把用户名和密码进行解密，然后把解密后的字符串重置到**properties**属性中。

- ```java
  public class SqlSessionFactoryUtils {
      private final static Class<SqlSessionFactoryUtils> LOCK = SqlSessionFactoryUtils.class;
  
      private static SqlSessionFactory sqlSessionFactory = null;
  
      private  SqlSessionFactoryUtils() {
      }
  
      public static SqlSessionFactory getSqlSessionFactory() throws IOException {
          synchronized (LOCK) {
              if (sqlSessionFactory != null) {
                  return sqlSessionFactory;
              }
              String resource = "mybatis-config.xml";
              InputStream inputStream;
                  //采用程序传递加密参数,启用它之前，修改用户密码为密文，可参考main方法......
  				InputStream in = Resources.getResourceAsStream("jdbc.properties");
  				Properties props = new Properties();
  				props.load(in);
  				String username = props.getProperty("database.username");
  				String password = props.getProperty("database.password");
  				// 解密用户和密码，并在属性中重置
  				props.put("database.username", CodeUtils.decode(username));
  				props.put("database.password", CodeUtils.decode(password));
  				inputStream = Resources.getResourceAsStream(resource);
  				// 使用程序传递的方式覆盖原有的properties属性参数
  				sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, props);
              return sqlSessionFactory;
          }
      }
      public static SqlSession openSqlSession() throws IOException {
          if (sqlSessionFactory == null) {
              getSqlSessionFactory();
          }
          return sqlSessionFactory.openSession();
      }
  
      public static void main(String[] args) {
          System.out.println(CodeUtils.encode("root"));
          System.out.println(CodeUtils.encode("123456"));
      }
  
      static class CodeUtils {
          private static String encode(String src) {
              BASE64Encoder encoder = new BASE64Encoder();
              return encoder.encode(src.getBytes());
          }
  
          private static String decode(String des) {
              BASE64Decoder decoder = new BASE64Decoder();
              try {
                  return new String(decoder.decodeBuffer(des));
              } catch (IOException e) {
                  e.printStackTrace();
              }
              return null;
          }
      }
  }
  ```

- **MyBatis**中使用**properties**的三种方式，最**优先的是使用程序传递的方式**，其次是**properties**文件的方式，最后是使用**property**子元素的方式，**MyBatis**会**根据优先级来覆盖原来配置的属性值**。

### Settings设置(了解)

- **settings**是**MyBatis**中最复杂的配置，它能影响**MyBatis**底层的运行，但是在**大多数情况下使用默认值**便可以运行，在使用过程中不需要大量配置它，只需要修改一些常用的规则即可。

|              配置项              | 作用                                                         | 配置选项说明                                                 | 默认值                                                       |
| :------------------------------: | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
|           cacheEnable            | 该配置影响所有映射器中配置缓存的全局开关                     | true\|false                                                  | true                                                         |
|        lazyLoadingEnable         | 延迟加载的全局开关。当开启时，所有设置对象都会延迟加载。在特定关联关系中可通过设置fechType属性来覆盖该项的开关选项 | true\|false                                                  | false                                                        |
|      aggressiveLazyLoading       | 当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载。 | true\|false                                                  | 版本3.4.1(不包含)之前true，之后false                         |
|    multipleResultSetsEnabled     | 是否允许单一语句返回多结果集(需要兼容驱动)                   | true\|false                                                  | true                                                         |
|          useColumnLabel          | 使用列标签代替列明。不同的驱动会有不同的表现                 | true\|false                                                  | true                                                         |
|         useGeneratedKeys         | 允许JDBC支持自动生成主键，需要驱动兼容。如果设置为true，则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍然可以正常工作(如：Derby) | true\|false                                                  | false                                                        |
|       autoMappingBehavior        | 指定MyBatis应如何自动映射列到字段或属性。NONE表示取消自动映射；PARTIAL表示只会自动映射，没有定义嵌套结果集和映射结果集。FULL会自动映射任意复杂的结果集(无论是否嵌套) | NONE,PARTIAL,FULL                                            | PARTIAL                                                      |
| autoMappingUnknownColumnBehavior | 指定自动映射当中未知列(或未知属性类型)时的行为。默认是不处理，只有当日志级别达到WARN级别或者以下，才会显示相关日志，如果处理失败会抛出sqlSessionException异常。 | NOEN,WARNING,FAILING                                         | NONE                                                         |
|       defaultExecutorType        | 配置默认的执行器。SIMPLE是普通的执行器；REUSE会重用预处理语言；BATCH执行器将重用语句并执行批量更新。 | SIMPLE,REUSE,BATCH                                           | SIMPLE                                                       |
|     defaultStatementTimeout      | 设置超时时间，它决定驱动等待数据库响应的秒数。               | 任何正整数                                                   | Not Set(null)                                                |
|       safeRowBoundsEnabled       | 允许在嵌套语句中使用分页(RowBounds)。如果允许，设置false。   | true\|false                                                  | false                                                        |
|     safeResultHandlerEnabled     | 允许在嵌套语句中使用分页(ResultHandler)。如果允许，设置false | true\|false                                                  | false                                                        |
|     mapUnderscoreToCamelCase     | 是否开启自动驼峰命名规则映射，即从经典数据库列名A_COLUMN到经典Java属性名aColumn的类似映射 | true\|false                                                  | true                                                         |
|         localCacheScope          | MyBatis利用本地缓存机制(Local Cache)防止循环引用和加速重复嵌套查询。默认值为SESSION，这种情况下会缓存一个会话中执行的所有查询，若设置值为STATEMENT，本地会话会仅用在语句执行上，对相同SqlSession的不同调用将不会共享数据。 | SESSION\|STATEMENT                                           | SESSION                                                      |
|         jdbcTypeForNull          | 当没有为参数提供的JDBC类型时，为空值指定JDBC类型，某些驱动需要指定列的JDBC类型，多数情况直接用一般类型即可，如：NULL,VARCHAR或OTHER。 | NULL\|VARCHAR\|OTHER                                         | OTHER                                                        |
|      lazyLoadTriggerMethods      | 指定那个对象的方法触发一次延迟加载                           | ----------------------------------                           | equals,clone,hashCode,toString                               |
|     defaultScriptingLanguage     | 指定动态SQL生成的默认语言                                    | -----------------------------------                          | org.apache.ibatis.scripting.xmltags.XMLDynamicLanguageDriver |
|        callSettersOnNulls        | 指定当结果集中值为null时，是否调用映射对象的setter(map对象为put())方法，这对于有Map.keySet()依赖或null值初始化时是有用的。注意，基本类型(int,boolean等)不能设置为null | true\|false                                                  | false                                                        |
|            logPrefix             | 指定MyBatis增加到日志名称的前缀                              | 任何字符串                                                   | Not set                                                      |
|             logImpl              | 指定MyBatis所用日志的具体实现，未指定时将自动查找            | SLF4J\|LOG4J\|LOG4J2</br>\|JDK_LOGGING\|COMMONS_LOGGING</br>\|STDOUT_LOGGING\|NO_LOGGING | Not set                                                      |
|           proxyFactory           | 指定MyBatis创建具有延迟加载能力的对象所用到的代理工具        | CGLIB\|JAVASSIST                                             | JAVASSIST(MyBatis版本为3.3及以上的)                          |
|             vfsImpl              | 指定VFS的实现类                                              | 提供VFS类的全限定名，如果存在多个，可以使用逗号分隔          | Not set                                                      |
|        useActuaParamname         | 允许用方法参数中声明的实际名称引用参数。要使用此功能，项目必须被编译为Java 8参数的选择(从版本3.4.1开始可以使用) | true\| false                                                 | true                                                         |
|         defaultFetchSize         | 设置数据库驱动程序默认返回的条数限制，此参数可以重新设置     | 任何正整数                                                   | Not Set(null)                                                |

####  全量settings的配置样例

- ```xml
  <sttings>
  	<setting name="cacheEnable" value="true"/>
  	<setting name="useColumnLabel" value="true"/>
  	<setting name="useGeneratedKeys" value="false"/>
  	<setting name="defaultFetchSize" value="100"/>
  	......
  </settings>	
  ```

### typeAliases别名

- 在**MyBatis**中允许定义一个简写来代表这个类，这就是别名，别名分为**系统定义别名**和**自定义别名**。在**MyBatis**中别名由类**TypeAliasRegistry(org.apache.ibatis.TypeAliasRegistry)**去定义，在**MyBatis**中别名**不区分大小写**。

#### 系统定义别名

- 在**MyBatis**的**初始化**过程中，系统自动初始化了一些别名。

| 别名       | Java类型   | 是否支持数组 |
| :--------- | ---------- | :----------- |
| _byte      | byte       | 是           |
| _long      | long       | 是           |
| _short     | short      | 是           |
| _int       | int        | 是           |
| _integer   | integer    | 是           |
| _double    | double     | 是           |
| _float     | float      | 是           |
| _boolean   | boolean    | 是           |
| string     | String     | 是           |
| byte       | Byte       | 是           |
| long       | Long       | 是           |
| short      | Short      | 是           |
| int        | Integer    | 是           |
| integer    | Integer    | 是           |
| double     | Double     | 是           |
| float      | Float      | 是           |
| boolean    | Boolean    | 是           |
| date       | Date       | 是           |
| decimal    | BigDecimal | 是           |
| bigdecimal | BigDecimal | 是           |
| object     | Object     | 是           |
| map        | Map        | 否           |
| hashmap    | HashMap    | 否           |
| list       | List       | 否           |
| arraylist  | ArrayList  | 否           |
| collection | Collection | 否           |
| iterator   | Iterator   | 否           |
| ResultSet  | ResultSet  | 否           |

- 如果需要使用对应类型的数组型，要看其是否能支持数组，如果支持只需要使用别名加[]即可，比如==_int==数组的别名就是==_int[]==。

##### MyBatis初始化别名

```java
public class TypeAliasRegistry {

  private final Map<String, Class<?>> TYPE_ALIASES = new HashMap<String, Class<?>>();

  public TypeAliasRegistry() {
    registerAlias("string", String.class);

    registerAlias("byte", Byte.class);
    registerAlias("long", Long.class);
    registerAlias("short", Short.class);
    registerAlias("int", Integer.class);
    registerAlias("integer", Integer.class);
    registerAlias("double", Double.class);
    registerAlias("float", Float.class);
    registerAlias("boolean", Boolean.class);

    registerAlias("byte[]", Byte[].class);
    registerAlias("long[]", Long[].class);
    registerAlias("short[]", Short[].class);
    registerAlias("int[]", Integer[].class);
    registerAlias("integer[]", Integer[].class);
    registerAlias("double[]", Double[].class);
    registerAlias("float[]", Float[].class);
    registerAlias("boolean[]", Boolean[].class);

    registerAlias("_byte", byte.class);
    registerAlias("_long", long.class);
    registerAlias("_short", short.class);
    registerAlias("_int", int.class);
    registerAlias("_integer", int.class);
    registerAlias("_double", double.class);
    registerAlias("_float", float.class);
    registerAlias("_boolean", boolean.class);

    registerAlias("_byte[]", byte[].class);
    registerAlias("_long[]", long[].class);
    registerAlias("_short[]", short[].class);
    registerAlias("_int[]", int[].class);
    registerAlias("_integer[]", int[].class);
    registerAlias("_double[]", double[].class);
    registerAlias("_float[]", float[].class);
    registerAlias("_boolean[]", boolean[].class);

    registerAlias("date", Date.class);
    registerAlias("decimal", BigDecimal.class);
    registerAlias("bigdecimal", BigDecimal.class);
    registerAlias("biginteger", BigInteger.class);
    registerAlias("object", Object.class);

    registerAlias("date[]", Date[].class);
    registerAlias("decimal[]", BigDecimal[].class);
    registerAlias("bigdecimal[]", BigDecimal[].class);
    registerAlias("biginteger[]", BigInteger[].class);
    registerAlias("object[]", Object[].class);

    registerAlias("map", Map.class);
    registerAlias("hashmap", HashMap.class);
    registerAlias("list", List.class);
    registerAlias("arraylist", ArrayList.class);
    registerAlias("collection", Collection.class);
    registerAlias("iterator", Iterator.class);

    registerAlias("ResultSet", ResultSet.class);
  }
    ......
```

- 所以通过使用**TypeAliasRegistry**的**registerAlias()**方法就可以注册别名了。一般是通过**Configuration**获取**TypeAliasRegistry**类对象，其中有一个**getTypeAliasRegistry()**方法可以获得别名，如**configuration.getTypeAliasRegistry()**。

#### 自定义别名

##### 使用配置文件或者扫描方式来自定义。

- 使用配置文件方式

- ```xml
  <typeAliases>
  	<typeAlias type="user" type="com.ym.learn.ssm.chapter4.pojo.User"/>
      <typeAlias type="role" type="com.ym.learn.ssm.chapter4.pojo.Role"/>
  </typeAliases>
  ```

- MyBatis还支持扫描别名。比如上面两个类都在同一个包下，那么可以定义为。

- ```xml
  <typeAliases>
  	<package name="com.ym.learn.ssm.chapter4.pojo"/>
  </typeAliases><
  ```

- 这样**Mybatis**将扫描这个包里面的类，将其**第一个字母变为小写**作为其别名，如：**User**会变为**user**。但是使用这样的规则，有时候会出现重名，比如**com.ym.learn.ssm.chapter3.pojo.User**这个类，**MyBatis**还增加了对包**com.ym.learn.ssm.chapter3.pojo**的扫描，那么就会出现异常，这个时候可以使用**MyBatis**提供的注解**@Alias("user3")**进行区分，如下

- ```java
  package com.ym.learn.ssm.chapter3.pojo;
  @Alias("user3")
  public class User {
      ...
  }
  ```

- 这样就可以避免因为重名导致的扫描失败问题。

### typeHandler类型转换器

- 在**JDBC**中，需要在**preparedStatement**对象中设置那些已经预编译过的**SQL**语句的参数，执行**SQL**后，会通过**ResultSet**对象获取得到数据库的数据，而这些**MyBatis**是根据数据的类型通过**typeHandler**来实现的。在**typeHandler**中，分为**jdbcType**和**javaType**，其中**jdbcType**是用于定义数据库类型，而**javaType**用于定义**java**类型，那么**typeHandler**的作用就是承担**jdbcType**和**javaType**之间的相互转换。
- 在很多情况下我们并不需要去配置**typeHandler**,**jdbcType**,**javaType**，因为**MyBatis**会探测应该使用什么类型**typeHandler**进行处理。
- 对于那些需要使用自定义枚举的场景，或者数据库使用特殊数据类型的场景，可以使用自定义的**typeHandler**去处理类型之间的转换关系。
- 在**MyBatis**中存在系统定义**typeHandler**和自定义**typeHandler**。**MyBatis**会根据**javaType**和数据库的**jdbcType**来决定采用那个**typeHandler**处理这些转换规则。

#### 系统定义的typeHandler

- **MyBatis**内部定义了许多有用的**typeHandler**。

| 类型处理器                 | Java类型                    | JDBC类型                                                  |
| -------------------------- | --------------------------- | --------------------------------------------------------- |
| BooleanTypeHandler         | java.lang.Boolean,boolean   | 数据库兼容的BOOLEAN                                       |
| ByteTypeHandler            | java.lang.Byte,byte         | 数据库兼容的NUMERIC或BYTE                                 |
| ShortTypeHandler           | java.lang.Byte,Short，short | 数据库兼容的NUMERIC或SHORT INTEGER                        |
| LongTypeHandler            | java.lang.Long,long         | 数据库兼容的NUMERIC或LONG INTEGER                         |
| FloatTypeHandler           | java.lang.Float,float       | 数据库兼容的NUMERIC或FLOAT                                |
| IntegerTypeHandler         | java.lang.Integer,int       | 数据库兼容的NUMERIC或INTEGER                              |
| DoubleTypeHandler          | java.lang.Double,double     | 数据库兼容的NUMERIC或DOUBLE                               |
| BigDecimalTypeHandler      | java.math.BigDecimal        | 数据库兼容的NUMERIC或DECIMAL                              |
| StringTypeHandler          | java.lang.String            | CHAR,VARCHAR                                              |
| ClobReaderTypeHandler      | java.io.Reader              | ——————                                                    |
| ClobTypeHandler            | java.lang.String            | CLOB,LONGVARCHAR                                          |
| NStringTypeHandler         | java.lang.String            | NVARCHAR,NCHAR                                            |
| NClobTypeHandler           | java.lang.String            | NCLOB                                                     |
| BlobInputStreamTypeHandler | java.io.InputStream         | ——————                                                    |
| ByteArrayTypeHandler       | byte[]                      | 数据库兼容的字节流类型                                    |
| BlobTypeHandler            | byte[]                      | BLOB,LONGVARBINARY                                        |
| DateTypeHandler            | java.util.Date              | TIMESTAMP                                                 |
| DateOnlyTypeHandler        | java.util.Date              | DATE                                                      |
| TimeOnlyTypeHandler        | java.util.Date              | TIME                                                      |
| SqlTimestampTypeHandler    | java.sql.Timestamp          | TIMESTAMP                                                 |
| SqlDateTypeHandler         | java.sql.Date               | DATE                                                      |
| SqlTimeTypeHandler         | java.sql.Time               | TIME                                                      |
| ObjectTypeHandler          | Any                         | OTHER或者未指定类型                                       |
| EnumTypeHandler            | Enumeration Type            | VARCHAR任何兼容的字符串类型，存储枚举的名称(而不是索引)   |
| EnumOrdinalTypeHandler     | Enumeration Type            | 任何兼容的NUMERIC或DOUBLE类型，存储枚举的索引(而不是名称) |

- 上面就是**MyBatis**已经创建好的**typeHandler**。大多数情况下，无需显式的声明**jdbcType**和**javaType**，或者用**typeHandler**去指定对应的**typeHandler**来实现数据类型转换，因为**MyBatis**会自己探测。

- 在**MyBatis**中**typeHandler**都要实现接口**org.apache.ibatis.type.TypeHandler**。

- ```java
  public interface TypeHandler<T> {
      void setParameter(PreparedStatement var1, int var2, T var3, JdbcType var4) throws SQLException;
  
      T getResult(ResultSet var1, String var2) throws SQLException;
  
      T getResult(ResultSet var1, int var2) throws SQLException;
  
      T getResult(CallableStatement var1, int var2) throws SQLException;
  }
  ```

- 其中**T**是泛型，专指**javaType**，如：我们需要**String**的时候，那么实现类可以写为**implements TypeHandler<String>**

- **setParameter()**，是使用**typeHandler**通过**PreparedStatement**对象进行设置**SQL**参数的时候使用的具体方法，其中**var2**是参数在**SQL**的下标，**var3**是参数，**var4**是数据库类型。

- **3个getResult()**方法，作用是从**JDBC**结果集中获取数据进行转换，要么使用列名，要么使用下标获取数据库的数据，其中最后一个**getResult()**是存储过程专用的。

- 在编写**typeHandle**时，需要继承**org.apache.ibatis.type.BaseTypeHandler**

- ```java
  public abstract class BaseTypeHandler<T> extends TypeReference<T> implements TypeHandler<T> {
      protected Configuration configuration;
  
      public BaseTypeHandler() {
      }
  
      public void setConfiguration(Configuration c) {
          this.configuration = c;
      }
  
      public void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException {
          if (parameter == null) {
              if (jdbcType == null) {
                  throw new TypeException("JDBC requires that the JdbcType must be specified for all nullable parameters.");
              }
  
              try {
                  ps.setNull(i, jdbcType.TYPE_CODE);
              } catch (SQLException var7) {
                  throw new TypeException("Error setting null for parameter #" + i + " with JdbcType " + jdbcType + " . " + "Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. " + "Cause: " + var7, var7);
              }
          } else {
              try {
                  this.setNonNullParameter(ps, i, parameter, jdbcType);
              } catch (Exception var6) {
                  throw new TypeException("Error setting non null for parameter #" + i + " with JdbcType " + jdbcType + " . " + "Try setting a different JdbcType for this parameter or a different configuration property. " + "Cause: " + var6, var6);
              }
          }
  
      }
  
      public T getResult(ResultSet rs, String columnName) throws SQLException {
          Object result;
          try {
              result = this.getNullableResult(rs, columnName);
          } catch (Exception var5) {
              throw new ResultMapException("Error attempting to get column '" + columnName + "' from result set.  Cause: " + var5, var5);
          }
  
          return rs.wasNull() ? null : result;
      }
  
      public T getResult(ResultSet rs, int columnIndex) throws SQLException {
          Object result;
          try {
              result = this.getNullableResult(rs, columnIndex);
          } catch (Exception var5) {
              throw new ResultMapException("Error attempting to get column #" + columnIndex + " from result set.  Cause: " + var5, var5);
          }
  
          return rs.wasNull() ? null : result;
      }
  
      public T getResult(CallableStatement cs, int columnIndex) throws SQLException {
          Object result;
          try {
              result = this.getNullableResult(cs, columnIndex);
          } catch (Exception var5) {
              throw new ResultMapException("Error attempting to get column #" + columnIndex + " from callable statement.  Cause: " + var5, var5);
          }
  
          return cs.wasNull() ? null : result;
      }
  
      public abstract void setNonNullParameter(PreparedStatement var1, int var2, T var3, JdbcType var4) throws SQLException;
  
      public abstract T getNullableResult(ResultSet var1, String var2) throws SQLException;
  
      public abstract T getNullableResult(ResultSet var1, int var2) throws SQLException;
  
      public abstract T getNullableResult(CallableStatement var1, int var2) throws SQLException;
  }
  ```

- **BaseTypeHandler**是一个抽象类，需要子类去实现其定义的四个抽象方法，而它本身只是实现了**typeHandler**接口的四个方法。

- **getResult**方法，非空结果集是通过**getNullableResult**方法获取的。如果判断为空，则返回**null**。

- **setParameter**方法，当参数**parameter**和**jdbcType**同时为空时，**MyBatis**将抛出异常。如果能明确**jdbcType**，则会进行空设置；如果参数不为空，那么它将采用**setNonNullParameter**方法设置参数。

- **getNullableResult**方法用于存储过程。

- **MyBatis**中使用最多的**typeHandler**之一**StringTypeHandler**。它用于字符串转换。

- ```java
  public class StringTypeHandler extends BaseTypeHandler<String> {
      public StringTypeHandler() {
      }
  
      public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
          ps.setString(i, parameter);
      }
  
      public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
          return rs.getString(columnName);
      }
  
      public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
          return rs.getString(columnIndex);
      }
  
      public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
          return cs.getString(columnIndex);
      }
  }
  ```

- **MyBatis**把**javaType**和**jdbcType**相互转换，那它们是如何注册的呢，在**MyBatis**中采用**org.apache.ibatis.type.TypeHandlerRegistry**类对象的**register**方法进行注册。

- ```java
  public TypeHandlerRegistry() {
          this.register((Class)Boolean.class, (TypeHandler)(new BooleanTypeHandler()));
          this.register((Class)Boolean.TYPE, (TypeHandler)(new BooleanTypeHandler()));
          this.register((JdbcType)JdbcType.BOOLEAN, (TypeHandler)(new BooleanTypeHandler()));
          this.register((JdbcType)JdbcType.BIT, (TypeHandler)(new BooleanTypeHandler()));
          this.register((Class)Byte.class, (TypeHandler)(new ByteTypeHandler()));
          this.register((Class)Byte.TYPE, (TypeHandler)(new ByteTypeHandler()));
          this.register((JdbcType)JdbcType.TINYINT, (TypeHandler)(new ByteTypeHandler()));
          this.register((Class)Short.class, (TypeHandler)(new ShortTypeHandler()));
          this.register((Class)Short.TYPE, (TypeHandler)(new ShortTypeHandler()));
  }
  ```

- 这样就实现了用代码的形式注册**typeHandler**。注意，自定义的**typeHandler**一般不会使用代码注册，**而是通过配置或扫描**。

#### 自定义typeHandler

- 要实现**typeHandler**就需要去实现接口**typeHandler**，或者继承**BaseTypeHandler**(**BaseTypeHandler**已经实现了接口**typeHandler**)

- ```java
  package com.ym.ssm.chapter4.typehandler;
  //......
  public class MyTypeHandler implements TypeHandler<String> {
      Logger logger = Logger.getLogger(MyTypeHandler.class);
      public void setParameter(PreparedStatement preparedStatement, int i, String s, JdbcType jdbcType) throws SQLException {
          logger.info("设置string参数【"+s+"】");
          preparedStatement.setString(i,s);
      }
  
      public String getResult(ResultSet resultSet, String s) throws SQLException {
          String result = resultSet.getString(s);
          logger.info("读取string参数1【"+result+"】");
          return result;
      }
  
      public String getResult(ResultSet resultSet, int i) throws SQLException {
          String result = resultSet.getString(i);
          logger.info("读取string参数2【"+result+"】");
          return result;
      }
  
      public String getResult(CallableStatement callableStatement, int i) throws SQLException {
          String result = callableStatement.getString(i);
          logger.info("读取string参数3【"+result+"】");
          return result;
      }
  }
  ```

- 配置typeHandler(mybatis-config.xml)

- ```xml
  <typeHandlers>
  		<typeHandler jdbcType="VARCHAR" javaType="string" handler="com.ym.ssm.chapter4.typehandler.MyTypeHandler" 
  			/>
  	</typeHandlers>
  ```

- 这样注册后，当**jdbcType**和**javaType**能与**MyTypeHandler**对应的时候，它就会启动**MyTypeHandler**。有时候还可以显示启用**typeHandler**，一般而言启动这个**typeHandler**有两种方式。

- ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <mapper namespace="com.ym.ssm.chapter4.mapper.RoleMapper">
  
  	<resultMap id="roleMapper" type="role">
  		<result property="id" column="id" />
  		<result property="roleName" column="role_name" jdbcType="VARCHAR"
  			javaType="string" />
  		<result property="note" column="note"
  			typeHandler="com.ym.ssm.chapter4.typehandler.MyTypeHandler" />
  	</resultMap>
  
  	<select id="getRole" parameterType="long" resultMap="roleMapper">
  		select id, role_name, note from t_role where id = #{id}
  	</select>
  
  	<select id="findRoles" parameterType="string" resultMap="roleMapper">
  		select id, role_name, note from t_role
  		where role_name like concat('%', #{roleName, jdbcType=VARCHAR,
  		javaType=string}, '%')
  	</select>
  
  	<select id="findRoles2" parameterType="string" resultMap="roleMapper">
  		select id, role_name, note from t_role
  		where note like concat('%', #{note,
  		typeHandler=com.ym.ssm.chapter4.typehandler.MyTypeHandler}, '%')
  	</select>
  </mapper>
  ```

- 要么指定了与自定义**typeHandler**一致的**jdbcType**和**javaType**，要么直接使用**typeHandler**指定的具体的实现类。

- 有时候由于枚举类型很多，系统需要的typeHandler会很多，如果采用配置会很麻烦，这个时候可以考虑使用包扫描的方式。

- ```xml
  <typeHandlers>
  		<!-- <typeHandler jdbcType="VARCHAR" javaType="string" handler="com.ym.ssm.chapter4.typehandler.MyTypeHandler"
  			/> -->
  		<package name="com.ym.ssm.chapter4.typehandler" />
  
  	</typeHandlers>
  ```

- 只是这样就没法指定**jdbcType**和**javaType**，不过我们可以使用注解来处理它们。

- ```java
  //启用扫描注册的时候需要注解
  @MappedTypes(String.class)
  @MappedJdbcTypes(JdbcType.VARCHAR)
  public class MyTypeHandler implements TypeHandler<String> {
  ```

#### 枚举typeHandler

- 在大多数情况下，**typeHandler**因为枚举而使用，**MyBatis**定义了**两个类**作为枚举类型的支持。

  - **EnumOrdinalTypeHandler**
  - **EnumTypeHandler**

- ```java
  //创建枚举类
  public enum SexEnum {
  	MALE(1, "男"),
  	FEMALE(0, "女");
  
  	private int id;
  	private String name;
  
  	//setting&getting
  	SexEnum(int id, String name) {
  		this.id = id;
  		this.name = name;
  	}
  
  	public static SexEnum getSexById(int id) {
  		for (SexEnum sex : SexEnum.values()) {
  			if (sex.getId() == id) {
  				return sex;
  			}
  		}
  		return null;
  	}
  }
  
  ```

- ```java
  //创建用户pojo
  public class User {
  	private Long id;
  	private String userName;
  	private String password;
  	private SexEnum sex;
  	private String mobile;
  	private String tel;
  	private String email;
  	private String note;
  	//setting&getting
  	}
  ```

##### EnumOrdinalTypeHandler
- **EnumOrdinalTypeHandler**是按**MyBatis**根据**数组下标索引**的方式进行匹配的，它要求数据库返回一个整数作为其下标，它会根据下标找到对应的枚举类型，可以根据这条规则，创建一个UserMapper.xml。

- ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper
      PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
      "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <mapper namespace="com.ym.ssm.chapter4.mapper.UserMapper">
    	<resultMap id="userMapper" type="user">
    		<result property="id" column="id" />
    		<result property="userName" column="user_name" />
    		<result property="password" column="password" />
    		<result property="sex" column="sex" 
                typeHandler="org.apache.ibatis.type.EnumOrdinalTypeHandler"/>
    		<result property="mobile" column="mobile" />
    		<result property="tel" column="tel" />
    		<result property="email" column="email" />
    		<result property="note" column="note" />
    	</resultMap>
    	<select id="getUser" resultMap="userMapper" parameterType="long">
    	  select id, user_name, password, sex, mobile, tel, email, note from t_user 
          where id = #{id}
    	</select>
    </mapper>
    ```

- ```java
  private static void testTypeHandler() {
  		Logger log = Logger.getLogger(Chapter4Main.class);
  		SqlSession sqlSession = null;
  		try {
  			sqlSession = SqlSessionFactoryUtils.openSqlSession();
  			UserMapper userMapper  = sqlSession.getMapper(UserMapper.class);
  			User user = userMapper.getUser(1L);
  			System.out.println(user.getSex().getName());
  		} finally {
  			if (sqlSession != null) {
  				sqlSession.close();
  			}
  		}
  	}
  ```

##### EnumTypeHandler

- **EnumTypeHandler**会把使用的名称转换为对应的枚举，比如它会根据数据库返回的字符串“**MALE**”，进行**Enum.valueOf(SexEnum.class,"MALE")**;转换，所以为了测试**EnumTypeHandler**的转换，我们需要把数据库的**sex**字段修改为**字符型**，并把**sex=1**的数据修改为**FEMALE**，需要执行下面的**SQL**。

- ```sql
  alter table t_user modify sex varchar(10);
  update t_user set sex = 'FEMALE' where sex = 1;
  ```

- 使用**EnumTypeHandler**修改**UserMapper.xml**

- ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <mapper namespace="com.ym.ssm.chapter4.mapper.UserMapper">
  	<resultMap id="userMapper" type="user">
  		<result property="id" column="id" />
  		<result property="userName" column="user_name" />
  		<result property="password" column="password" />
          <result property="sex" column="sex" 
              typeHandler="org.apache.ibatis.type.EnumTypeHandler"/> 
  		<result property="mobile" column="mobile" />
  		<result property="tel" column="tel" />
  		<result property="email" column="email" />
  		<result property="note" column="note" />
  	</resultMap>
  	<select id="getUser" resultMap="userMapper" parameterType="long">
  	  select id, user_name, password, sex, mobile, tel, email, note from t_user 
        where id = #{id}
  	</select>
  </mapper>
  ```

##### 自定义枚举typeHandler

- **MyBatis**提供的两种转换**typeHandler**，但是它们有很大的局限性，更多的时候我们希望使用自定义的**typeHandler**。执行**sql**，把数据库的**sex**字段修改为整数型。

- ```sql
  update t_user set sex='0' where sex = 'FEMALE';
  update t_user set sex='1' where sex = 'MALE';
  alter table t_user modify sex int(10);
  ```

- 创建自定义SexEnumTypeHandler

- ```java
  public class SexEnumTypeHandler implements TypeHandler<SexEnum> {
  
  
  	public void setParameter(PreparedStatement ps, int i, SexEnum parameter,
  			JdbcType jdbcType) throws SQLException {
  		ps.setInt(i, parameter.getId());
  	}
  
  
  	public SexEnum getResult(ResultSet rs, String columnName)
  			throws SQLException {
  		int id = rs.getInt(columnName);
  		return SexEnum.getSexById(id);
  	}
  
  
     public SexEnum getResult(ResultSet rs, int columnIndex) throws SQLException {
  		int id = rs.getInt(columnIndex);
  		return SexEnum.getSexById(id);
  	}
  
  
  	public SexEnum getResult(CallableStatement cs, int columnIndex)
  			throws SQLException {
  		int id = cs.getInt(columnIndex);
  		return SexEnum.getSexById(id);
  	}
  
  }
  ```

- 修改UserMapper.xml

- ```xml
  ...
   <result property="sex" column="sex"
              typeHandler="com.ym.ssm.chapter4.typehandler.SexEnumTypeHandler"/>
  ...
  ```

### ObjectFactory(工厂对象)

- 当创建结果集时，**MyBatis**会使用一个工厂对象来完成创建这个结果集实例，**MyBatis**会使用其定义的对象工厂——**DefaultObjectFactory**(**org.apache.ibatis.reflection.factory.DefaultObjectFactory**)来完成对应的工作。

- **MyBatis**允许注册自定义的**ObjectFactory**。需要实现接口**org.apache.ibatis.reflection.factory.ObjectFactory**，并给予配置，但是大多数情况下会考虑继承系统已经实现好的**DefaultObjectFactory**,通过一定的改写来完成我们所需要的工作。

- 自定义ObjectFactory

  - ```java
    public class MyObjectFactory extends DefaultObjectFactory {
        private static final long serialVersionUID = -8855120656740914948L;
        private Object temp = null;
    
        @Override
        public void setProperties(Properties properties) {
            super.setProperties(properties);
            System.out.println("初始化参数：【"+properties.toString()+"】");
        }
    
        @Override
        public <T> T create(Class<T> type) {
            T result = super.create(type);
            System.out.println("创建对象"+result.toString());
            System.out.println("是否和上次创建的是同一个对象:【"+(temp == result)+"】");
            return result;
        }
    
        @Override
        public <T> T create(Class<T> type, List<Class<?>> constructorArgTypes, List<Object> constructorArgs) {
            T result = super.create(type, constructorArgTypes, constructorArgs);
            System.out.println("创建对象"+result.toString());
            temp = result;
            return result;
        }
    
        @Override
        public <T> boolean isCollection(Class<T> type) {
            return super.isCollection(type);
        }
    }
    ```

- 在mybatis-config.xml中配置MyObjectFactory

  - ```xml
    <objectFactory type="com.ym.ssm.chapter4.factory.MyObjectFactory">
    		<property name="prop1" value="value1"/>
    	</objectFactory>
    ```

- 添加测试

  - ```java
    private static void testRoleMapper() {
    		Logger log = Logger.getLogger(Chapter4Main.class);
    		SqlSession sqlSession = null;
    		try {
    			sqlSession = SqlSessionFactoryUtils.openSqlSession();
    			RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);
    			Role role = roleMapper.getRole(1L);
    			log.info(role.getRoleName());
    		} finally {
    			if (sqlSession != null) {
    				sqlSession.close();
    			}
    		}
    	}
    ```



### environments(运行环境)

- 运行环境主要的作用是配置数据库信息，它可以配置多个数据库。它下面又分为两个可配置的元素：
  - 事务管理器(**transactionManager**)
  - 数据源(**dataSource**)

- 运行环境配置
  - ```xml
    <environments default="development">
    		<environment id="development">
    			<transactionManager type="JDBC" />
    			<dataSource type="POOLED">
    				<property name="driver" value="${database.driver}" />
    				<property name="url" value="${database.url}" />
    				<property name="username" value="${database.username}" />
    				<property name="password" value="${database.password}" />
    			</dataSource>
    		</environment>
    	</environments>
    ```

#### transactionManager

- 在**MyBatis**中，**transactionManager**提供了两个实现类(**JdbcTransaction**,**ManagedTransaction**)，它需要实现接口**Transaction(org.apache.ibatis.transaction.Transaction)**

- ```java
  public interface Transaction {
      Connection getConnection() throws SQLException;
  
      void commit() throws SQLException;
  
      void rollback() throws SQLException;
  
      void close() throws SQLException;
  
      Integer getTimeout() throws SQLException;
  }
  ```

- 事务管理器的两种配置方式

  - ```xml
    <transactionManager type="JDBC" />
    ```

  - ```XML
    <transactionManager type="MANAGED" />
    ```

  - **JDBC**使用**jdbcTransactionFactory**生成的**JdbcTransaction**对象实现。它是以**JDBC**的方式对数据库的提交和回滚进行操作。

  - **MANAGED**使用**ManagerTransactionFactory**生成**ManagedTransaction**对象实现。它的提交和回滚方法不用任何操作，而是把事务交给容器实现。在默认情况下，它会关闭连接，然而一些容器并不希望这样，因此需要将**closeConnection**属性设置为**false**来阻止它默认的关闭行为。

- 不想采用MyBatis的规则时，我们可以这样进行配置。

  - ```xml
    <transactionManager type="xxx.xxx.xxx.xxx.xxx.MyTransactionFactory" />
    ```

  - ```java
    //自定义事务工厂
    public class MyTransactionFactory implements TransactionFactory {
        public void setProperties(Properties properties) {
            
        }
    
        public Transaction newTransaction(Connection connection) {
            return new MyTransaction(connection);
        }
    
        public Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel transactionIsolationLevel, boolean b) {
            return new MyTransaction(dataSource,transactionIsolationLevel,b);
        }
    }
    
    ```

  - 这里实现了**TransactionFactory**所定义的工厂方法，这个时候还需要事务实现类**MyTransaction**，它用于实现**Transaction**接口。

  - ```java
    public class MyTransaction extends JdbcTransaction implements Transaction {
        public MyTransaction(DataSource ds, TransactionIsolationLevel level,boolean desiredAutoCommit) {
            super(ds,level,desiredAutoCommit);
        }
        public MyTransaction(Connection connection) {
            super(connection);
        }
    
        @Override
        public Connection getConnection() throws SQLException {
            return super.getConnection();
        }
    
        @Override
        public void commit() throws SQLException {
            super.commit();
        }
    
        @Override
        public void rollback() throws SQLException {
            super.rollback();
        }
    
        @Override
        public void close() throws SQLException {
            super.close();
        }
    
        @Override
        public Integer getTimeout() throws SQLException {
            return super.getTimeout();
        }
    }
    
    ```

  - 这样就可以通过自定义事务规则，满足特殊需要。

#### environment数据源环境

- **environment**的主要作用是配置数据库，在**MyBatis**中，数据库通过**PooledDataSourceFactory**，**UnpooledDataSourceFactory**和**JndiDataSourceFactory**三个工厂类来提供，无论如何这三个工厂类，最后生成的产品都会是一个实现了**DataSource**接口的数据库连接对象。

- 由于存在三种数据源，所以我们可以按照下面的形式进行配置。

  - ```xml
    <dataSource type="UNPOOLED">
    ```

  - ```xml
    <dataSource type="POOLED">
    ```

  - ```xml
    <dataSource type="JNDI">
    ```

##### UNPOOLED

- **UNPOOLED**采用非数据库池的管理方式，每次请求都会打开一个新的数据库连接，所以创建比较慢，在一些对性能没有很高的场合可以使用。**UNPOOLED**类型的数据源可以配置以下几种属性：
  - **driver**数据库驱动名，如：**MySQL**的**com.mysql.jdbc.Driver**。
  - **url**连接数据库的**URL**。
  - **username**用户名。
  - **password**密码。
  - **defaultTransactionIsolationLevel**默认的连接事务隔离级别。

##### POOLED

- 数据源**POOLED**利用“**池**”的概念将**JDBC**的Co**n**nection对象组织起来，它开始会有一些空置，并且已经连接好的数据库连接，所以请求时，无须再建立和验证，省去了创建新的连接实例时所必须的初始化和认证时间。它还能控制最大连接数。
- 除了**UNPOOLED**下的属性外，还有更多属性用来配置**POOLED**的数据源。
  - **poolMaximumActiveConnections**是在任意时间都存在的活动(也就是正在使用)连接数量，默认值10。
  - **poolMaximumIdleConnections**是任意时间可能存在的空闲连接数。
  - **poolMaximumCheckoutTime**在被强制返回之前，池中连接被检出(checked out)的时间，默认值为**20000**毫秒。
  - **poolTimeToWait**是一个底层设置，如果获取连接花费相当长的时间，它会给连接池打印状态日志，并重新尝试获取一个连接(避免在误配置的情况下一致失败)，默认值为**20000**毫秒。
  - **poolPingQuery**为发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中，并准备接受请求。默认是"**NO PING QUERY SET**"，这会导致多数数据库驱动失败时带有一个恰当的错误信息。
  - **poolPingEnabled**为是否启用侦测查询，若开启，也必须使用一个可执行的**SQL**语句设置**poolPingQuery**属性(最好是一个非常快的**SQL**)，默认值为**false**。
  - **poolPingConnectionsNotUsedFor**为配置**poolPingQuery**的使用频度。这可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测，默认值为**0**(即所有连接每一时刻都被侦测——仅当**poolPingEnable**为**true**时适用)

##### JNDI

- 数据源**JNDI**的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个**JNDI**上下文引用。这种数据源配置只需要两个属性。
  - **initial_context**用来在**InitialContext**中寻找上下文。**initial_context**是一个可选属性，如果忽略，那么**data_source**属性将会直接从**InitialContext**中寻找。
  - **data_source**是引用数据源实例位置上下文的路径。当提供**initial_context**配置时，**data_source**会在其返回的上下文中进行查找；当没有提供**initial_context**时，**data_source**直接在**InitialContext**中查找。

##### 第三方数据源

- **MyBatis**也支持第三方数据源，如使用**DBCP**数据源，那么就需要提供一个自定义的**DataSourceFactory**。

  - ```java
    public class DbcpDataSourceFactory implements DataSourceFactory {
    	private Properties props = null;
    
    	@Override
    	public void setProperties(Properties props) {
    		this.props = props;
    	}
    
    	@Override
    	public DataSource getDataSource() {
    		DataSource dataSource = null;
    		try {
    			dataSource = BasicDataSourceFactory.createDataSource(props);
    		} catch (Exception ex) {
    			ex.printStackTrace();
    		}
    		return dataSource;
    	}
    }
    ```

- 然后进行如下配置

  - ```xml
    <dataSource type="com.learn.ssm.chapter4.datasource.DbcpDataSourceFactory">
    				<property name="driver" value="${database.driver}" />
    				<property name="url" value="${database.url}" />
    				<property name="username" value="${database.username}" />
    				<property name="password" value="${database.password}" />
    			</dataSource>
    ```

- 这样**MyBatis**就会采用配置的数据源工厂来生成数据源了。

### databaseIdProvider数据库厂商标识

- **databaseldProvider**元素主要是支持多种不同厂商的数据库。

#### 系统默认的databaseldProvider

- 使用databaseIdProvider需要配置一些属性(mybatis-config.xml)。

  - ```xml
    <databaseIdProvider type="DB_VENDOR">
    		<property name="Oracle" value="oracle" />
    		<property name="MySQL" value="mysql" />
    		<property name="DB2" value="db2" />
    	</databaseIdProvider>
    ```

  - **property**元素的属性**name**是数据库的名称，而**value**是它的一个别名，在**MyBatis**中通过这个别名标识一条**SQL**适用于那种数据库运行。

- 修改映射器SQL

  - ```xml
    <select id="getRole" parameterType="long" resultType="role" databaseId="oracle">
    		select id, role_name as roleName, note from t_role where id = #{id}
    	</select>
    	<select id="getRole" parameterType="long" resultType="role" databaseId="mysql">
    		select id, role_name as roleName, note from t_role where 1=1 and id = #{id}
    	</select>
    ```


- 输出


  - DEBUG 2019-12-08 22:55:19,829 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==>  Preparing: select id, role_name as roleName, note from t_role where 1=1 and id = ? 
    DEBUG 2019-12-08 22:55:19,939 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==> Parameters: 1(Long)
    DEBUG 2019-12-08 22:55:19,975 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: <==      Total: 1
  - 当我们使用MySQL数据库时，它会执行第二条sql语句。

- 那如果同时存在一条有databaseId和没有databaseId的标识会发生什么呢？


  - ```xml
    <select id="getRole" parameterType="long" resultType="role" databaseId="oracle">
    		select id, role_name as roleName, note from t_role where id = #{id}
    	</select>
    	<select id="getRole" parameterType="long" resultType="role">
    		select id, role_name as roleName, note from t_role where 1=1 and id = #{id}
    	</select>
    ```

- 输出


  - DEBUG 2019-12-08 23:02:26,615 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==>  Preparing: select id, role_name as roleName, note from t_role where 1=1 and id = ? 
    DEBUG 2019-12-08 23:02:26,706 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: ==> Parameters: 1(Long)
    DEBUG 2019-12-08 23:02:26,742 org.apache.ibatis.logging.jdbc.BaseJdbcLogger: <==      Total: 1

- 那如果配置的databaseId没有？


  - ```xml
    <select id="getRole" parameterType="long" resultType="role" databaseId="oracle">
    		select id, role_name as roleName, note from t_role where id = #{id}
    	</select>
    	<select id="getRole" parameterType="long" resultType="role" databaseId="db2">
    		select id, role_name as roleName, note from t_role where 1=1 and id = #{id}
    	</select>
    ```

- 输出


  - ```cmd
    Exception in thread "main" org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.ym.ssm.chapter4.mapper.RoleMapper.getRole
    	at org.apache.ibatis.binding.MapperMethod$SqlCommand.<init>(MapperMethod.java:223)
    	at org.apache.ibatis.binding.MapperMethod.<init>(MapperMethod.java:48)
    	at org.apache.ibatis.binding.MapperProxy.cachedMapperMethod(MapperProxy.java:59)
    	at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:52)
    	at com.sun.proxy.$Proxy5.getRole(Unknown Source)
    	at com.ym.ssm.chapter4.main.Chapter4Main.testRoleMapper(Chapter4Main.java:24)
    	at com.ym.ssm.chapter4.main.Chapter4Main.main(Chapter4Main.java:14)
    
    ```

- 通过上面的实践我们知道。当**databaseIdProvidertype**属性被配置时，系统会优先取到和数据库配置一致的**SQL**。如果没有，则取没有**databaseId**的**SQL**，可以把它当作默认值。如果还是取不到，则会抛出异常，说明无法匹配到对应地**SQL**。

#### 使用自定义规则

- 必须实现MyBatis提供的接口DatabaseIdProvider。

  - ```java
    public class MyDatabaseIdProvider implements DatabaseIdProvider {
    
    	private static final String DATEBASE_TYPE_DB2 = "DB2";
    	private static final String DATEBASE_TYPE_MYSQL = "MySQL";
    	private static final String DATEBASE_TYPE_ORACLE = "Oralce";
    
    	private Logger log = Logger.getLogger(MyDatabaseIdProvider.class);
    
    
    	public void setProperties(Properties props) {
    		log.info(props);
    	}
    
    
    	public String getDatabaseId(DataSource dataSource) throws SQLException {
    		Connection connection = dataSource.getConnection();
    		String dbProductName = connection.getMetaData().getDatabaseProductName();
    		if (MyDatabaseIdProvider.DATEBASE_TYPE_DB2.equals(dbProductName)) {
    			return "db2";
    		} else if (MyDatabaseIdProvider.DATEBASE_TYPE_MYSQL
    				.equals(dbProductName)) {
    			return "mysql";
    		} else if (MyDatabaseIdProvider.DATEBASE_TYPE_ORACLE
    				.equals(dbProductName)) {
    			return "oracle";
    		} else {
    			return null;
    		}
    	}
    
    }
    ```

- 配置mybatis-config.xml

  - ```xml
    <databaseIdProvider
    		type="com.ym.ssm.chapter4.databaseidprovider.MyDatabaseIdProvider">
    		<property name="msg" value="自定义DatabaseIdProvider" />
    	</databaseIdProvider>
    ```

### 引入映射器的方法

- 映射器是MyBatis最复杂，最核心的组件。

- 映射器定义命名空间(namespace)的方法，命名空间对应的是一个接口的全路径，而不是实现类。

- 定义接口。

  - ```java
    public interface RoleMapper {
    	public Role getRole(Long id);
    }
    ```

- 配置Mapper映射规则和SQL语句

  - ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
      "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <mapper namespace="com.ym.ssm.chapter4.mapper.RoleMapper">
    	<select id="getRole" parameterType="long" resultType="role">
    		select id, role_name as roleName, note from t_role where id = #{id}
    	</select>
    </mapper>
    ```

- 引入映射器的方式比较多，一般分为如下几种

  - 用文件路径引入映射器

    - ```xml
      <mappers>
      		<mapper resource="com/ym/ssm/chapter4/mapper/roleMapper.xml" />
      	</mappers>
      ```

  - 用包名引入映射器

    - ```xml
      <mappers>
      		<package name="com.ym.ssm.chapter4.mapper" />
      	</mappers>
      ```

  - 用类注册引入映射器

    - ```xml
      <mappers>
      		<mapper class="com.ym.ssm.chapter4.mapper.UserMapper" />
          	<mapper class="com.ym.ssm.chapter4.mapper.RoleMapper" />
      </mappers>
      ```

  - 用userMapper.xml引入映射器

    - ```xml
      <mappers>
      		<mapper url="file:///var/mappers/com/ym/ssm/charter4/mapper/UserMapper.xml"/>
      		<mapper url="file:///var/mappers/com/ym/ssm/charter4/mapper/RoleMapper.xml"/>
      </mappers>
      ```